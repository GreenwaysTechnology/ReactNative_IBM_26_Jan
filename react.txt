		 React/React.js
.....................................................................................

What is react?
 	A JavaScript library for building user interfaces.

User interfaces:

1.Desktop
2.Browser based web 
3.mobile app

React was created for building web based interface, later react started in mobile development

React - browser
React Native - mobile


....................................................................................
			DOM,VDOM (V.TREE)
.....................................................................................

What is DOM?
   DOM is specification  released by W3c organization order to build web apps for browsers.

in order to understand DOM fully , we need to understand HTML very deeply.

HTML:

1.HTML IS PL? - YES
2.HTML Is compiled -YES
3.HTML is excuted-YES

Hello.java --->compile--->Hello.class--->run----JVM(Runtime) executes code.

index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
-------------------Browser
loader---LOAD Code into browser
 |
  from file: or http:
|
Parser :
   Parser is special compiler which converts source code into lexical tree(string tree)
|
body
  div
     h1
        Welcome 
     h1
  div
body
|
|
Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body

.....................................................................................
				Runtime 
.....................................................................................
HTML Execution engine : Request Os ,to allocate memory :Runtime


-LinkedList - c language

body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body
|
 Linking the Nodes: Tree
body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
|
 Layout/Paint Engine: will convert nodes into pxs : final output
....................................................................................
..............................................................................................
Static web pages: HTMLs are displayed into browser.
..............................................................................................
In 1996,Netscap communication, Started an RND project called "How to manipulate the tree"

Tree is written in c language, then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

that is birth of javascript.

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

............................................................................................

How dom works?

index.html           Browser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT Inside JavaScript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	*************************************************************************************
Who and when "H1" object is created?

if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()


<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?

Note: For html elements, we cant create object directly, rather than JS Engine will create objects , return references to the developer to access.
 How via factory Objects: object helps to get other documents


Factory Object : HTML Document =>body

document.getElementById();
   |
Implicit object reference variable which points HTMLDocument OBject.
...................................................................................
What is our objective here? DOM Programming?
Enter into DOM programming:

1.write dom programming using javascript language.

<body>
  |
HTMLDocument : body : factory Object


Document apis:

Finding HTML Elements

HTMLElement document.getElementById(id)
      Find an element by element id
HTMLElement Document document.getElementsByTagName(name)
	Find elements by tag name
HTMLElement document.getElementsByClassName(name)
	Find elements by class name

HTMLElement document.querySelectory(selector) 
      find element/elements by selector


Changing HTML Elements : update existing element
......................
element.innerHTML =  new html content	Change the inner HTML of an element
element.attribute = new value	Change the attribute value of an HTML element
element.style.property = new style	Change the style of an HTML element
Method	Description
element.setAttribute(attribute, value)	Change the attribute value of an HTML element

Adding and Deleting Elements
document.createElement(element)	Create an HTML element
document.removeChild(element)	Remove an HTML element
document.appendChild(element)	Add an HTML element
document.replaceChild(new, old)	Replace an HTML element

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
									   React as Dom lib
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

React project setup:
.................................

in order to create project or mange project, build project, deploy project -  you need build tools

In java we use maven or Gradle.

In JavaScript we use node based build tool called "npm or npx". This tool is available only along with node.
if you want to use npm or npx you must have installed node.js

React teams offers tool set to create react project.

create-react-app:
 This old tool to create react application, almost this tool has been moved into maintenance .

vite:
 Now a days vite based tools are becoming very popular.

npm:
 node package manager

npm create vite@latest my-app

Need to install the following packages:
create-vite@6.5.0
Ok to proceed? (y) y


> npx
> create-vite

|
o  Project name:
|  myreactapp
|
o  Select a framework:
|  React
|
o  Select a variant:
|  JavaScript
|
o  Scaffolding project in G:\IBM\2025\May\ReactNative\myreactapp...
|
—  Done. Now run:

  cd myreactapp
  npm install
  npm run dev

...................................................................................
			Exploring Project Structure
...................................................................................

package.json
{
  "name": "myreact-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.13.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.3",
    "eslint": "^9.13.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "globals": "^15.11.0",
    "vite": "^5.4.10"
  }
}
index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

src/main.jsx : root File
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
									   DOM programming using plain js
..........................................................................................................................................................................................................................................
function createNode() {
    const Heading = document.createElement('h1')
    Heading.innerHTML = 'Hello React!'
    console.dir(Heading)
    //get the element where you want to insert
    const rootElement = document.getElementById('root')
    rootElement.appendChild(Heading)
}
createNode()
.....................................................................................
			DOM Programming using React.js
.....................................................................................

// import ReactDOM from 'react-dom/client'
import { createRoot } from "react-dom/client"

//declare DOM 
const Heading = <h1>Hello React! How are you?</h1>

// const rootElement = document.getElementById('root')
// ReactDOM.createRoot(rootElement).render(Heading)

// ReactDOM.createRoot(document.getElementById('root')).render(Heading)
createRoot(document.getElementById('root')).render(Heading)

.......................................................................................................................................................................................................................................
					JSX - java script and XML - language to create User interfaces
......................................................................................................................................................................................................................................

React uses declarative Dom programing using a mini language invented by Facebook : JSX

JSX : - JavaScript xml

 1.PL language built by face book to write user interfaces.
 2.JSX is collection of html markup and JavaScript.
 3.JSX is DSL and declarative.
 4.Every device has its own JSX language syntax.
 5.Browsers JSX can't be used for building mobile application.


Since JSX  is a language cant be executed on browser /mobile directly.
..................................................................................
JSX compilation model:

                   layout.js / layout.jsx
		       |
		    compiler - babel.js 
			|
		    plain js code
			|-----------------------Dev cycle
	----------------------------------------- -- Execution cycles Starts
  Runtime : React Engine  compiled code feed into react engine
			|
		     Execute compiled js code : function calls
			|
	     create virtual Object tree (in browser V-dom)
		        |
		     Render Engine ; will convert react object tree into js dom object tree
			|
		   Flush the tree into target
			|
	--------------------------------------------
        |      |
     Browser  Mobile

Since jsx  is a language cant be executed on browser /mobile directly.

JSX is used to create dom elements.

Every DOM element is object.

.........................................................................................................................................................................................................................................
				Component
.................................................................................

What is Component ?
  Component is Object , Coined by MS in 1989.

According to ms, Component is object which has state(data),behavior(methods) + User interface(Visual).
 eg:Button,TextBox,Grid,Menu,MenuBar,Layout,Table.....

Component === Widget ==== Object ==== DOM

Like Object tree(DOM Tree), In React we can create "Component" Tree.


      Node===DOM Object====Component
       h1   --->  HTML Heading--->   Heading

"React apps are made out of components. A Component is piece of the UI that has its own logic and appearance, A Component can be small as a button or as large as an entire Page"

.....................................................................................

In coding 

There two libs 
1.react.js  => to create component and manages all features related component.
2.react-dom => Render engine.

react.js

1.React
  It top level class which provides all apis to create,delete,update components.

react-dom.js

2.ReactDOM

   It is top level class which provides api to flush the v.dom into real dom.

........................................................................................................................................................................................................................................
								Component Creational patterns
.........................................................................................................................................................................................................................................


1.variable pattern
2.functional pattern
3.es 6 class pattern

     					Components can be created any one or mixed way  style.
   					"functional Pattern" is more popular and recommended pattern....



1.variable pattern
import { createRoot } from "react-dom/client"

//variable pattern 
//Here Heading is just variable , referencing the Component
//<h1>xxx</h1> -  Component
const Heading = <h1>Hello React! How are you?</h1>

createRoot(document.getElementById('root')).render(Heading)


2.functional pattern

 2.1.normal function - es 5 function
 2.1.arrow function -  es 6 function 

es 5 function:
import { createRoot } from "react-dom/client"

//functions 
function Heading() {
    return <h1>Hello, React!</h1>
}

createRoot(document.getElementById('root')).render(Heading())

render(Heading()) -  here we invoke function which is not recommended 

render(<Heading></Heading>) - here we use like html tag 
render(<Heading/>) - here we use like html tag -self closing

import { createRoot } from "react-dom/client"

//functions 
function Heading() {
    return <h1>Hello, React!</h1>
}

// createRoot(document.getElementById('root')).render(Heading())
// createRoot(document.getElementById('root')).render(<Heading></Heading>)

createRoot(document.getElementById('root')).render(<Heading/>)


2.1.arrow function -  es 6 function 
import { createRoot } from "react-dom/client"

//arrow
// const Heading = () => {
//     return <h1>Hello, React!</h1>
// }
const Heading = () => <h1>Hello, React!</h1>

createRoot(document.getElementById('root')).render(<Heading />)
.....................................................................................
			 ES6 Classes
.....................................................................................
The latest react echo system, does not recommend to go with class patterns.

import React from "react"
import { createRoot } from "react-dom/client"

class Heading extends React.Component {

    render() {
        return <h1>Hello React!!</h1>
    }
}


createRoot(document.getElementById('root')).render(<Heading />)
....................................................................................
							Exploring JSX
.....................................................................................

JS-JavaScript
X -  XML

	Since HTML parser is weak, but when y write react code, we need consistent code generation.

So that react team, developed compiler follows basic xml rules.

Basic XML  rules:

1.every opened element must be closed
  <h1>Hello</h1>
  <Welcome></Welcome>
 some elements may not have closing tag
  <img /> : image element has no child elements : self closing. 

import { createRoot } from "react-dom/client"

const Heading = ()=>{
    return <h1>Hello
}


createRoot(document.getElementById('root')).render(<Heading />)

[plugin:vite:react-babel] G:\IBM\2024\Nov\ReactiveNative-B1\myreact-app\src\main.jsx: Unterminated JSX contents. (8:62)

   6 |
   7 |
>  8 | createRoot(document.getElementById('root')).render(<Heading />)


2. In xml you must have one single root element.
  all elements must be organized under single root element.

   <h1>Welcome to IBM</h1>
   <p>Hello</p>

In html what can be root element
 <div>,<span>,all html 5 layout elements header,footer,section,aside...

import { createRoot } from "react-dom/client"

const Heading = ()=>{
    return <h1>Hello</h1>
           <p>This is element</p>
}


createRoot(document.getElementById('root')).render(<Heading />)

Solution:
import { createRoot } from "react-dom/client"

const Heading = () => {
    return <div><h1>Hello</h1>
        <p>This is element</p>
    </div>
}


createRoot(document.getElementById('root')).render(<Heading />)


3.Self closing:
import { createRoot } from "react-dom/client"
import logo from './assets/react.svg';

const Heading = () => {
    return <div>
        <img src={logo} />
    </div>
}


createRoot(document.getElementById('root')).render(<Heading />)

4.Component Name must be Pascal Case
  It has to start with capital letter
  It should be Noun

import { createRoot } from "react-dom/client"
import logo from './assets/react.svg';

const heading = () => {
    return <div>
        <img src={logo} />
    </div>
}


createRoot(document.getElementById('root')).render(<heading />)


hook.js:608 Warning: The tag <heading> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter
..........................................................................................................................................................................................................................................
			  				  Fragments
....................................................................................................................

There might be use case where i don't want root element, but without root element compiler gives error.
Can we skip the root element without compile time error.

 Yes

Fragments:
  
   Fragments are invisible root element , just only compilation purpose


Syntax:

 1.<React.Fragment>
 </React.Fragement>
2.<Fragment>
 </Fragement>
3.<>
 </>
import ReactDOM from 'react-dom/client';
// import React, { Fragment } from 'react';

// const Welcome = () => {
//     return <React.Fragment>
//         <h1>Site Heading</h1>
//         <p>This is react</p>
//     </React.Fragment>
// }

// const Welcome = () => {
//     return <Fragment>
//         <h1>Site Heading</h1>
//         <p>This is react</p>
//     </Fragment>
// }

const Welcome = () => {
    return <>
        <h1>Site Heading</h1>
        <p>This is react</p>
    </>
}

const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(<Welcome />)
........................................................................................................................................................................................................................
								 Data binding
....................................................................................................................

Create  new project:

>npm create vite@latest data-binding

As of now we have seen only how to create static UI - (only HTML)

How to represent data?
->primitives - string,numbers,boolean
->objects - object,arrays

How to bind data?
  {variable} {expression}
 
  {a} {fun()} {10*2} {isHidden ? 'Show':'Hide'} 


Simple Databinding:

const User = () => {
    //variables
    const id = 1
    const userName = 'Subramanian Murugan'
    const email = 'sasubramanian_m@hotmail.com'
    const address = {
        city: 'Coimbatore'
    }
    const status = true

    return <div>
        <h1>User info</h1>
        <h3>Id : {id}</h3>
        <h3>Name : {userName}</h3>
        <h4>Email : {email}</h4>
        <h4>City : {address.city}</h4>
        <h4>Status : {status ? "Available" : "Not Available"}</h4>
    </div>

}
export { User }

If you look at the code above, data is declared within component is tightly coupled.

When you think about component you have to about reusability.

What if i want to show different user information? How to create component in reusable manner?

     ->Properties
..............................................................................................
			Data binding patterns

1.props pattern /property pattern
2.state pattern

How to create reusable component?

 Component must be parametrized or configurable....

You know very well component is function, just js function, when you think about function, you can pass parameter....


Use case: invoke function and pass data
........................................

src/User.jsx

const User = (id,userName,email,address,status) => {
    return <div>
        <h1>User info</h1>
        <h3>Id : {id}</h3>
        <h3>Name : {userName}</h3>
        <h4>Email : {email}</h4>
        <h4>City : {address.city}</h4>
        <h4>Status : {status ? "Available" : "Not Available"}</h4>
    </div>
}
export { User }

src/App.jsx
import { User } from "./users/User";

function App() {
    return <>
        {User(1, 'Subramanian Murugan', 'subu@gmail.com', { city: 'Coimbatore' }, true)}
    </>
}

export default App;
.................................................................................
			Passing props and receiving props with declarative pattern
................................................................................

src/users/User.jsx

//props is not keyword just variable convention
//props hold object , object has all properties what ever we passed from parent
const User = (props) => {
    console.log(props)
    return <div>
        <h3>Id : {props.id}</h3>
        <h3>Name : {props.userName}</h3>
        <h4>Email : {props.email}</h4>
        <h4>City : {props.address.city}</h4>
        <h4>Status : {props.status ? "Available" : "Not Available"}</h4>
    </div>
}
export { User }

src/App.jsx
import { User } from "./users/User";

// function App() {
//     return <>
//         {User(1, 'Subramanian Murugan', 'subu@gmail.com', { city: 'Coimbatore' }, true)}
//         {User(2, 'Murugan', 'murugan@gmail.com', { city: 'Chennai' }, false)}
//     </>
// }

function App() {
    return <>
           <User id={1} email='subu@gmail.com' userName='Subramanian Murugan'  address={{ city: 'Coimbatore' }} status={true} />
           <User id={1} email='subu@gmail.com' userName='Subramanian Murugan'  address={{ city: 'Coimbatore' }} status={true} />
           <User id={1} email='subu@gmail.com' userName='Subramanian Murugan'  address={{ city: 'Coimbatore' }} status={true} />
           <User id={1} email='subu@gmail.com' userName='Subramanian Murugan'  address={{ city: 'Coimbatore' }} status={true} />
    </>

}
export default App;
................................................................................
		Code Refactoring -  Object DE structuring and props
...............................................................................

Destructuring within function:
const User = (props) => {
    const { id, userName, email, address: { city }, status } = props
    return <div>
        <h3>Id : {id}</h3>
        <h3>Name : {userName}</h3>
        <h4>Email : {email}</h4>
        <h4>City : {city}</h4>
        <h4>Status : {status ? "Available" : "Not Available"}</h4>
    </div>
}
export { User }

Destructuring with function args
const User = ({ id, userName, email, address: { city }, status }) => <div>
    <h3>Id : {id}</h3>
    <h3>Name : {userName}</h3>
    <h4>Email : {email}</h4>
    <h4>City : {city}</h4>
    <h4>Status : {status ? "Available" : "Not Available"}</h4>
</div>

export { User }
..............................................................................
		Adding feature to the User Component -Image-Avatar
		   Component Composition and Props
...............................................................................
src/avatar/Avatar.jsx

const Avatar = ({ profilePic }) => <img src={profilePic} height={100} width={100} />

export { Avatar }

src/users/User.jsx
import { Avatar } from "../avatar/Avatar"

const User = ({ id, userName, email, address: { city }, status, profilePic }) => <div>
    {/* <img src={profilePic} height={100} width={100} /> */}
    <Avatar profilePic={profilePic} />
    <h3>Id : {id}</h3>
    <h3>Name : {userName}</h3>
    <h4>Email : {email}</h4>
    <h4>City : {city}</h4>
    <h4>Status : {status ? "Available" : "Not Available"}</h4>
</div>

export { User }

src/App.jsx
import { User } from "./users/User";

function App() {
    const profilePic = 'https://imgur.com/1bX5QH6.jpg'
    return <>
        <User id={1} profilePic={profilePic} email='subu@gmail.com' userName='Subramanian Murugan' address={{ city: 'Coimbatore' }} status={true} />
    </>

}
export default App;

How to inspect component tree?
 React dev tools
..................................................................................................................................................................................................................................
									 Default Props
....................................................................................................................................................................................................................................

component can receive more no number of properties, all properties we don't need it, if you want to use only specific properties , then we can use default props

Having defaults for any component when you design it.


src/users/User.jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'

const User = ({ id = 0, userName = 'Your Name', email = 'Your email', address: { city = "Your City", state = "Your state" } = {}, status = false }) => <div>
    <h3>Id : {id}</h3>
    <h3>Name : {userName}</h3>
    <h4>Email : {email}</h4>
    <h4>City : {city}</h4>
    <h4>State :{state}</h4>
    <h4>Status : {status ? "Available" : "Not Available"}</h4>
</div>

const App = () => {
    return <>
        <User id={1} email='subu@gmail.com' userName='Subramanian Murugan' address={{ city: 'Coimbatore' }} status={true} />
        <User />
    </>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

.................................................................................
			Forwarding Props with jsx Spread Notation
.................................................................................

Use Case : with Spread Notation:
................................
src/users/UserDetails.jsx
import { Avatar } from "../avatar/Avatar"

const UserDetails = ({ id = 0, userName = 'Your Name', email = 'Your email', city = "Your City", status = false, profilePic = '' }) => <div>
    <Avatar profilePic={profilePic} />
    <h3>Id : {id}</h3>
    <h3>Name : {userName}</h3>
    <h4>Email : {email}</h4>
    <h4>City : {city}</h4>
    <h4>Status : {status ? "Available" : "Not Available"}</h4>
</div>

export { UserDetails }

src/users/User.jsx
import { UserDetails } from "./UserDetails"

const User = ({ id = 0, userName = 'Your Name', email = 'Your email', address: { city = "Your City" }, status = false, profilePic = '' }) => <div>
    <UserDetails id={id}
        userName={userName}
        email={email}
        city={city}
        status={status}
        profilePic={profilePic} />
</div>



export { User }
src/App.jsx
import { User } from "./users/User";

function App() {
    const profilePic = 'https://imgur.com/1bX5QH6.jpg'
    return <>
        <User id={1} profilePic={profilePic} email='subu@gmail.com' userName='Subramanian Murugan' address={{ city: 'Coimbatore' }} status={true} />
    </>
}
export default App;


........

    <UserDetails id={id}
        userName={userName}
        email={email}
        city={city}
        status={status}
        profilePic={profilePic} />

Here we pass every prop manually, that can be avoided using spread notation.

Using Spread Notation:
src/users/User.jsx
import { UserDetails } from "./UserDetails"

const User = props => <div>
    {/* ... is Spread Notation: pass every property */}
    <UserDetails {...props}  />
</div>

export { User }
............................................................................................
				List Render
............................................................................................		
How to render list/Array?

npm create vite@latest list-app


To iterate list in react/reactnative

1.map
2.filter
3.find
4.reduce

based on arrays we can create many layouts

1.listView - ul--li
2.gridView - table tag
3.cardView - div/section

using map:

App.jsx

import { List } from "./list/List";

function App() {

  const subjects = ['React', 'ReactNative', 'Javascript', 'Mobile', 'Devops', 'Cloud']
  return <>
    <List subjects={subjects} />
  </>
}
export default App;

src/list/List.jsx

const List = (props) => {
    return <div>
        <h1>List</h1>
        <ul>
            {
                props.subjects.map(subject => {
                    return <li>{subject}</li>
                })
            }
        </ul>
    </div>
}
export { List }
.........................................................................................
		      How to render list of objects
...........................................................................................
Using mock data

import { ProductList } from "./list/List";
import { PRODUCTS } from "./mock-data/products";

function App() {

    return <>
        <ProductList products={PRODUCTS} />
    </>
}
export default App;

List.jsx

const ProductList = ({ products }) => {
    return <div>
        {
            products.map(product => {
                return <div key={product.id}>
                    <h2>{product.title}</h2>
                    <img src={product.image} height={150} width={150} />
                    <h5>Category: {product.category} Price : $ {product.price}</h5>
                    <p>{product.description} </p>
                    <h3>Rating : {product.rating.rate} Total {product.rating.count}</h3>
                </div>
            })
        }
    </div>
}
export { ProductList }
...........................................................................................
				Component Composition and List
...........................................................................................

List.jsx
import { ListItem } from "./ListeItem"

const ProductList = ({ products }) => <div>{
    products.map(product => <ListItem product={product} />)
}
</div>

export { ProductList }

ListItem.jsx

const ListItem = props => {
    return <div key={props.product.id}>
        <h2>{props.product.title}</h2>
        <img src={props.product.image} height={150} width={150} />
        <h5>Category: {props.product.category} Price : $ {props.product.price}</h5>
        <p>{props.product.description} </p>
        <h3>Rating : {props.product.rating.rate} Total {props.product.rating.count}</h3>
    </div>
}
export { ListItem }

App.jsx
import { ProductList } from "./list/List";
import { PRODUCTS } from "./mock-data/products";

function App() {

    return <>
        <ProductList products={PRODUCTS} />
    </>
}
export default App;

.....................................................................................................................................................................................................................................
											Styling
..........................................................................................................................................................

web apps which are running inside browser, is based "CSS" styling language.

There are two ways to apply CSS to react components

1.external styles
2.inline style

external styles are applied via style sheet.

app.css, index.css

style selectors

inside code

import './App.css'

<div className="background">

</div>

inline Style:
  css styles are applied via JavaScript object style object

<div style={StyleObject} </div>

import { createRoot } from 'react-dom/client'

const profiles = [
    {
        id: 1,
        name: 'Raja',
        role: "Front End Developer",
        email: "raja@company.com",
        avatar: "https://i.pravatar.cc/150?img=1"
    },
    {
        id: 1,
        name: 'Rahul',
        role: "Back End Developer",
        email: "rahul@company.com",
        avatar: "https://i.pravatar.cc/150?img=2"

    },
    {
        id: 3,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=3"

    },
    {
        id: 4,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=10"

    },
    {
        id: 5,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=9"

    },
    {
        id: 6,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=8"

    },
    {
        id: 7,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=7"

    },
    {
        id: 8,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=6"

    },
    {
        id: 9,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=5"

    },
    {
        id: 10,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=4"

    },
    {
        id: 11,
        name: 'Divya',
        role: "UI/UX Designer",
        email: "divya@company.com",
        avatar: "https://i.pravatar.cc/150?img=11"

    }
]


function App() {
    return <div style={styles.page}>
        <header style={styles.header}>
            <h2>Dashboard</h2>
        </header>
        <div styles={styles.main}>
            <aside style={styles.sidebar}>
                Side Bar
            </aside>
            <section style={styles.content}>
                <h3>Team Members</h3>
                <div style={styles.cards}>
                    {
                        profiles.map(profile => {
                            return <section key={profile.id} style={styles.card}>
                                <img
                                    src={profile.avatar}
                                    alt={profile.name}
                                    style={styles.avatar}
                                />
                                <div style={styles.name}>{profile.name}</div>
                                <div style={styles.role}>{profile.role}</div>
                                <div style={styles.email}>{profile.email}</div>

                            </section>
                        })
                    }

                </div>
            </section>
            <footer style={styles.footer}>
                @2026 Company
            </footer>
        </div>
    </div>
}

createRoot(document.getElementById('root')).render(
    <App />
)
const styles = {
    page: {
        display: "flex",
        flexDirection: "column",
        minHeight: "100vh",
        fontFamily: "sans-serif",
        backgroundColor: "#fafafa"
    },
    header: {
        padding: 20,
        backgroundColor: "#222",
        color: "#fff",
        textAlign: "center"
    },
    main: {
        display: "flex",
        flex: 1,
    },
    sidebar: {
        width: 200,
        backgroundColor: "#f4f4f4",
        padding: 20
    },
    content: {
        flex: 1,
        padding: 20,
        minWidth: 0,
        backgroundColor: "#c8ffff"

    },
    cards: {
        display: "flex",
        gap: 10,
        flexWrap: "wrap"
    },
    card: {
        width: 220,
        backgroundColor: "#fff",
        borderRadius: 8,
        padding: 15,
        boxShadow: "0 2px 8px rgba(202, 14, 14, 0.1)",
        textAlign: "center"
    },
    avatar: {
        width: 80,
        height: 80,
        borderRadius: "50%",
        objectFit: "cover",
        marginBottom: 10
    },
    name: {
        fontSize: 18,
        fontWeight: "bold",

    },
    role: {
        fontSize: 14,
        color: "#777",
        marginBottom: 8

    },
    email: {
        fontSize: 13,
        color: "#555"

    },

    footer: {
        padding: 15,
        backgroundColor: "#222",
        color: "#fff",
        textAlign: "center"
    }
}


You can write your own css styles, but mostly not recommended, because we have to use css frameworks 

1.bootstrap
2.tailwindcss

How to integrate tailwind css framework:

Steps:
01.
Create your project
Start by creating a new Vite project if you don’t have one set up already. The most common approach is to use Create Vite.

npm create vite@latest styling-app
cd  styling-app


02
Install Tailwind CSS
Install tailwindcss and @tailwindcss/vite via npm.

npm install tailwindcss @tailwindcss/vite


03
Configure the Vite plugin
Add the @tailwindcss/vite plugin to your Vite configuration.


vite.config.js
import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
})
with React:
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(),tailwindcss()],
})


04
Import Tailwind CSS
Add an @import to your CSS file that imports Tailwind CSS

src/index.css
@import "tailwindcss";

05.Add in the src/main.jsx
import './index.css'

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'

// const styles = { fontWeight: 'bold', fontSize: 80, color: 'blue' }
const styles = {
    header: {
        fontWeight: 'bold', fontSize: 80, color: 'blue'
    },
    container: {
        backgroundColor: 'yellow'
    }
}

const Header = () => {
    return <div className="m-40" style={styles.container}>
        <h1 style={{ fontWeight: 'bold', fontSize: 80, color: 'blue' }}>Hello</h1>
        <h1 style={styles.header}>Hello</h1>

    </div>
}


const App = () => {
    return <>
        <Header />
    </>
}
createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
					State Mutation getting started
.................................................................................................................................................................................................................................

How Component can change the data?

-Via State

How state can be changed

-Via Events

import React from "react";


class Review extends React.Component {

    //declare state
    state = {
        //your state
        like: 0
    }
    //listener 
    onLike = () => {
        this.state.like++
        console.log(this.state)
    }
    render() {
        console.log(this.state)
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}</h2>
            <button onClick={this.onLike}>Like</button>
        </div>
    }
}

function App() {
    return <>
        <Review />
    </>
}
export default App;


In the above we have incremented, like inside listener, but no update in UI

Why?
  
  UI logic is written inside render function,
  When ever like is changed, we need to call render function, so that ui could be updated with  new like data.

How to call render?

import React from "react";


class Review extends React.Component {

    //declare state
    state = {
        //your state
        like: 0
    }
    //listener 
    onLike = () => {
        this.state.like++
        // console.log(this.state)
        this.render()
    }
    render() {
        console.log('render is called')
        console.log(this.state)
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}</h2>
            <button onClick={this.onLike}>Like</button>
        </div>
    }
}

function App() {
    return <>
        <Review />
    </>
}
export default App;

You can notice in the above, we have called render inside listener, render is called but no UI update.

Why?

Can we call render method directly inside event listener...

Yes, but no impact on ui update...

   onLike = () => {
        this.state.like++
        console.log(this.state.like)
        this.render()
        console.log('onLike is clicked')
    }
Note: render should be not called directly in order to update user interface..
..........................................................................................
		Before writing code, we need to learn the concept
.................................................................................
		    Functional Programming principles
.................................................................................

Programming paradigms:
 any programming language is built on the top of programming paradigms
 Collections of set of principles and concepts.

Most popular programming paradigms.
1.Object oriented
   C++,java,C#......
2.Procedural oriented
   C
3.Functional Programming 
   LISP,Clojure,scheme,js

Some languages follow multiple paradigms (hybrid) , some follow single paradigm (solo)

javascript is object based, functional style programming language.
java is object oriented,functional style programming...

What is functional programming?

  It is type of programming paradigm.

functional programming is the first programming paradigm introduced in 1935, as part of Mathletics called "Lambda Calculus".

The first functional programming language called "LISP" was created in 1955.

React uses fp principles:

1.Pure functions
2.Immutability

Pure Functions:

Pure functions are defined by two rules..

Rule A:
  if function receives input, the function returns the input without any mutation...

//fp principles : rule A:


//is this function is pure or not : pure 
function Hello(message) {
    return message
}
console.log(Hello('hello'))

//is this function is pure or not: impure function
function doubleIt(value) {
    return value * 2
}
console.log(doubleIt(20))


Are we applying pure function rule "a" in React?


Yes,With Respect to "props" every function is pure.



//Pure function rule A in react.
import ReactDOM from 'react-dom/client';

//Every component is  based on pure function with respect to "props"
const Welcome = props => {
    //props.message = 'hai' // props are read only
     return <div>
        <h1>{props.message}</h1>
    </div>
}

const App = () => {
    return <>
        <Welcome message="hello" />
    </>
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
.....................................................................................
				Pure Function Rule B
....................................................................................

Rule B:
.......
 if function receives input, what if i want to change(mutate),We can apply rule b.
 
if function receives input, and modify input , we should return new object every time, which is called immutability. 


//pure function Rule B


function updateProfile(city, profile) {
    //update profile city 
    profile.city = city
 
    return profile
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

Result:
before update {name: 'Subramanian', city: 'Coimbatore'}
index.js:18 Same Object
index.js:19 after update {name: 'Subramanian', city: 'Chennai'}

The above code is pure or not?

The above is not pure, it is impure.

 "I need to mutate state(data), but at the same time, i need purity"
			
	                  Apply Immutability Principle


What is immutability?

  When ever you update the data(object), you have to create new object every time.

In order to write immutable code, js supports many patterns

1. Plain js pattern.
//pure function Rule B

function updateProfile(city, profile) {
    //return new object
    return {
        name: profile.name,
        city: city
    }
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

Plain js pattern has some drawback, we have to copy all the properties manually...

2.Object.assign pattern
//pure function Rule B

function updateProfile(city, profile) {
    //Object.assign 
    return Object.assign({}, profile, { city: city })
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

3.ES 7 Spread operator 
//pure function Rule B

function updateProfile(city, profile) {
      return { ...profile, city }
}

let profile = {
    name: 'Subramanian',
    city: 'Coimbatore'
}

console.log('before update', profile)
const result = updateProfile('Chennai', profile)
console.log(profile === result ? "Same Object" : "Different Object")
console.log('after update', result)

.....................................................................................
			Arrays -Pure functions (immutability)
.....................................................................................

Array pure functions:

1.map
  map is pure function , which returns new array when you iterate.

2.filter
  filter is also function, which returns new array when you iterate.

map:

function transform(data) {

    return data.map(item => item)
}

let list = ['subramanian', 'ram', 'murugan']

const response = transform(list)

console.log(list === response ? "Same" : "Different")

filter:


function filter(data) {

    return data.filter(item => item.status === true)
}

let employees = [{
    id: 1,
    name: 'subramanian',
    status: true
},
{
    id: 2,
    name: 'Ram',
    status: false
},
{
    id: 3,
    name: 'Karthik',
    status: true
},
{
    id: 4,
    name: 'Murugan',
    status: false
}

]

const response = filter(employees)

console.log(employees === response ? "Same" : "Different")
.................................................................................
Add Item:

push

//is it pure or not
function add(todos, todo) {
    return todos.push(todo)
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));


Response:
Uncaught TypeError: Cannot add property 1, object is not extensible

You are trying to add  on exiting memory... which is not pure and immutable...

so "array.push" is not pure function.

How to add item into array with purity:

Solution:

1.concat
   it is pure and immutable method..

//is it pure or not
function add(todos, todo) {
   // return todos.push(todo)
   return todos.concat(todo)
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));

2.Using spread operator

//is it pure or not
function add(todos, todo) {
    // return todos.push(todo)
    //  return todos.concat(todo)
    return [...todos, todo]
}
let todos = [{
    title: 'Learn react',
    done: true
}];

//Testing 
Object.freeze(todos)

console.log(add(todos, { title: 'Learn Microservices', done: false }));
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
....................................................................................
				React state mutation and pure functions
.....................................................................................

this.setState()
  pure function which returns immutable object always..

syntax:
 this.setState(function(state,props){
     //return immutable object
    return {} / object.assign / spread notation
 })

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import React from 'react'

class Review extends React.Component {
    //declare component(Review State)
    state = {
        like: 0
    }
    //listener
    onIncrement = () => {
        //you have to write pure function so that react automatically updates
        //react provides inbuilt pure functio through which we can mutate state
        //prevState is just variable points this.state only
        this.setState((prevState) => {
            //return immutable object
            //way 1
            // return {
            //     like: prevState.like + 1
            // }
            //way -2
            // return Object.assign({}, prevState, { like: prevState.like + 1 })
            //way -3 
            return { ...prevState, like: prevState.like + 1 }
        })
        //after returning new state, react engine internally invokes render, so that ui 
        //is updated

    }

    render() {
        console.log('state inside Render : ', this.state)
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}</h2>
            <button onClick={this.onIncrement}>Like</button>
        </div>
    }
}


const App = () => {
    return <>
        <Review />
    </>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

.............
code Refactoring:
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import React from 'react'

class Review extends React.Component {
    state = {
        like: 0
    }
    onIncrement = () => {
        // this.setState((prevState) => {
        //     return { ...prevState, like: prevState.like + 1 }
        // })
        // this.setState((prevState) => ({ ...prevState, like: prevState.like + 1 }))
        this.setState(({ ...this.state, like: this.state.like + 1 }))
    }

    render() {
        console.log('state inside Render : ', this.state)
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}</h2>
            <button onClick={this.onIncrement}>Like</button>
        </div>
    }
}
const App = () => {
    return <>
        <Review />
    </>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

.................................................................................
		Multi State variable
.................................................................................
import React from "react";


class Review extends React.Component {

    state = {
        like: 0,
        dislike: 0
    }
    //listener 
    onLike = () => {
        this.setState(prevState => {
            return { ...prevState, like: prevState.like + 1 }
        })
    }
    onDislike = () => {
        this.setState(prevState => {
            return { ...prevState, dislike: prevState.dislike + 1 }
        })
    }
    render() {
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}  Dislike : {this.state.dislike}</h2>
            <button onClick={this.onLike}>Like</button>
            <button onClick={this.onDislike}>Dislike</button>

        </div>
    }
}

function App() {
    return <>
        <Review />
    </>
}
export default App;
................................................................................
								InLine Listeners
...............................................................................
import React from "react";


class Review extends React.Component {
    state = {
        like: 0,
        dislike: 0
    }
    render() {
        return <div>
            <h1>Review App</h1>
            <h2>Like : {this.state.like}  Dislike : {this.state.dislike}</h2>
            <button onClick={() => {
                this.setState(prevState => {
                    return { ...prevState, like: prevState.like + 1 }
                })
            }}>Like</button>
            <button onClick={() => {
                this.setState(prevState => {
                    return { ...prevState, dislike: prevState.dislike + 1 }
                })
            }}>Dislike</button>

        </div>
    }
}

function App() {
    return <>
        <Review />
    </>
}
export default App;
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
								Item Selection and State
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//list and listener: select item 

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import React from 'react'
import PRODUCTS from './mock-data/products'

class Products extends React.Component {
    state = {
        products: PRODUCTS,
        selectedProduct: null
    }

    //method to get product data which is not listner
    onProductSelected = (product) => {
        // this.setState((prevState) => {
        //     return {
        //         ...prevState, selectedProduct: product
        //     }
        // })
        this.setState(({ ...this.state, selectedProduct: product }))
    }
    render() {
        return <div>
            {
                this.state.products.map(product => {
                    return <section key={product.id}>
                        <p style={{ cursor: 'pointer' }} onClick={() => {
                            this.onProductSelected(product)
                        }}>{product.title}</p>
                    </section>
                })
            }
            {this.state.selectedProduct ? <div>
                <h1>Id : {this.state.selectedProduct.id}</h1>
                <h2>Price :{this.state.selectedProduct.price}</h2>
                <img src={this.state.selectedProduct.image} height={100} width={100} />
            </div> : <h1>No Product Selected</h1>}

        </div>
    }
}


const App = () => {
    return <>
        <Products />
    </>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

..................................................................................................
			Component Composition: state as prop, listener as prop
	   	     			(Dynamic Prop)
..............................................................................................

Yes,With Respect to "props" every function is pure.

................................................................................
	Component Composition: state as prop, listener as prop
	   	     (Dynamic Prop)
..............................................................................
import React from "react";


class Review extends React.Component {
    state = {
        like: 0,
        dislike: 0
    }
    onLike = () => {
        this.setState(prevState => {
            return { ...prevState, like: prevState.like + 1 }
        })
    }
    onDislike = () => {
        this.setState(prevState => {
            return { ...prevState, dislike: prevState.dislike + 1 }
        })
    }
    render() {
        return <ReviewDashboard {...this.state} onLike={this.onLike} onDislike={this.onDislike} />
    }
}
const ReviewDashboard = props => {
    return <div>
        <h1>Review App</h1>
        <h2>Like : {props.like}  Dislike : {props.dislike}</h2>
        <button onClick={props.onLike}>Like</button>
        <button onClick={props.onDislike}>Dislike</button>
    </div>
}

function App() {
    return <>
        <Review />
    </>
}
export default App;

.......................................................................................................
                            setState and Object Destructuring
.....................................................................................................
								
import React from "react";


class Review extends React.Component {
    state = {
        like: 0,
        dislike: 0
    }
    onLike = () => {
        // this.setState(prevState => {
        //     return { ...prevState, like: prevState.like + 1 }
        // })
        // this.setState(prevState => ({ ...prevState, like: prevState.like + 1 }))

        this.setState(({ ...this.state, like: this.state.like + 1 }))

    }
    onDislike = () => {
        // this.setState(prevState => ({ ...prevState, dislike: prevState.dislike + 1 }))
        this.setState(({ ...this.state, dislike: this.state.dislike + 1 }))

    }
    render() {
        return <ReviewDashboard {...this.state} onLike={this.onLike} onDislike={this.onDislike} />
    }
}
const ReviewDashboard = props => {
    return <div>
        <h1>Review App</h1>
        <h2>Like : {props.like}  Dislike : {props.dislike}</h2>
        <button onClick={props.onLike}>Like</button>
        <button onClick={props.onDislike}>Dislike</button>
    </div>
}

function App() {
    return <>
        <Review />
    </>
}
export default App;

.....................................................................................................
					Nested State
....................................................................................................

simple state:

state = {
   like:0
}


State with in state:
.................................
state= {
   house:{
     name:'RavenClaw',
     points:10
   }
}
import React from "react";


class Review extends React.Component {
    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        },

    }

    onLike = () => {
        this.setState(prevState => {
            return {
                ...prevState, //level-0-copy // copy all outer keys of state
                house: {
                    ...prevState.house, // level-1 copy //copy all state except points
                    points: prevState.house.points + 1
                }

            }
        })
    }
    render() {
        return <div>
            <h1>House Review App</h1>
            <h2>{this.state.house.name}</h2>
            <h2>Points {this.state.house.points}</h2>
            <button onClick={this.onLike}>Like</button>
        </div>
    }
}


function App() {
    return <>
        <Review />
    </>
}
export default App;

.....................................................................................
				Deep Nesting
.....................................................................................

Assigment:
    state = {
        customer: {
            id: 1,
            name: 'Subramanian',
            contact: {
                address: {
                    city: 'Chennai'
                },
                communication: {
                    mobileNo: '9000000'
                }
            }
        }
    }

How to update mobileNo - 834343434

import React from 'react'
import './index.css'

class Customer extends React.Component {
    state = {
        customer: {
            id: 1,
            name: 'Subramanian',
            contact: {
                address: {
                    city: 'Chennai'
                },
                communcation: {
                    mobileNo: '9000000'
                }
            }
        }
    }
    render() {
        return <div>
            <h1>Customer info</h1>
            <h2>Name : {this.state.customer.name}</h2>
            <h2>Phone : {this.state.customer.contact.communcation.mobileNo}</h2>
            <button onClick={() => {
                this.setState((prevState) => {
                    return {
                        ...prevState, // leve-0 copy
                        customer: {
                            ...prevState.customer, // level-1 copy
                            contact: {
                                ...prevState.customer.contact, // level-2 copy
                                communcation: {
                                    ...prevState.customer.communcation,
                                    mobileNo: '4444444'
                                }
                            }
                        }
                    };
                  

                })
            }}>Update Mobile No</button>
        </div>
    }
}

export default function App(){
    return <Customer/>
}
..........................................................................................................................................................................................................................................
		Update state using immutability syntax and mutable syntax
......................................................................................................................................................................................................................................

Immutablity syntax:
 this.setState((prevState) => {
                    return {
                        ...prevState, // leve-0 copy
                        customer: {
                            ...prevState.customer, // level-1 copy
                            contact: {
                                ...prevState.customer.contact, // level-2 copy
                                communcation: {
                                    ...prevState.customer.communcation,
                                    mobileNo: '4444444'
                                }
                            }
                        }
                    };
                  

Mutable syntax:

this.state.customer.contact.communcation.mobileNo = '343434343434'

	The mutable syntax you cant use inside setState, but now a days is possible how?

		      Complexity of Immutable Objects 
					 and 
			How to solve  them using 
			     immer.js
..........................................................................................................................................................
What is immer?
  immer is simple js lib, which helps to write complex immutable code in "mutable way" like regular JavaScript way.


immutable syntax to update object property:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

     return {
                ...prevState, //level -0 copy
                house: {
                    ...prevState.house, // level-1 copy
                    points: prevState.house.points + 2
                }
        }

js syntax:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

update state:

state.house.points +=2

immer is lib which takes care of writing immutable code on behalf of us, developer writes mutable code, immer converts into immutable code.


Immer core concept:

immer provides a function called "produce"

produce(state,(draft)=>{
   draft.house.points +=2
})

produce function must be written inside this.setState function.


Getting started:

steps:

1.install immer lib

npm i immer

import { produce } from "immer";
import React from "react";

class Review extends React.Component {
    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        },

    }

    onLike = () => {
        //using immutable logic
        // this.setState(prevState => {
        //     return {
        //         ...prevState, //level-0-copy // copy all outer keys of state
        //         house: {
        //             ...prevState.house, // level-1 copy //copy all state except points
        //             points: prevState.house.points + 1
        //         }
        //     }
        // })

        // this.setState(prevState => {
        //     return produce(prevState, draft => {
        //         //write logic
        //         draft.house.points += 1
        //     })
        // })
        // this.setState(prevState => produce(prevState, draft => {
        //     //write logic
        //     draft.house.points += 1
        // }))
        this.setState(produce(this.state, draft => {
            //write logic
            draft.house.points += 1
        }))
    }
    render() {
        return <div>
            <h1>House Review App</h1>
            <h2>{this.state.house.name}</h2>
            <h2>Points {this.state.house.points}</h2>
            <button onClick={this.onLike}>Like</button>
        </div>
    }
}


function App() {
    return <>
        <Review />
    </>
}
export default App;


Another Example:

import React from 'react'
import './index.css'
import { produce } from 'immer'

class Customer extends React.Component {
    state = {
        customer: {
            id: 1,
            name: 'Subramanian',
            contact: {
                address: {
                    city: 'Chennai'
                },
                communcation: {
                    mobileNo: '9000000'
                }
            }
        }
    }
    render() {
        return <div>
            <h1>Customer info</h1>
            <h2>Name : {this.state.customer.name}</h2>
            <h2>Phone : {this.state.customer.contact.communcation.mobileNo}</h2>
            <button onClick={() => {
                this.setState(produce(this.state, (draft) => {
                    draft.customer.contact.communcation.mobileNo = '8883434343'
                }))
            }}>Update Mobile No</button>
        </div>
    }
}

export default function App() {
    return <Customer />
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Mutable syntax:

this.state.customer.contact.communcation.mobileNo = '343434343434'

	The mutable syntax you cant use inside setState, but now a days is possible how?

		      Complexity of Immutable Objects 
					 and 
			How to solve  them using 
			     immer.js
..........................................................................................................................................................
What is immer?
  immer is simple js lib, which helps to write complex immutable code in "mutable way" like regular JavaScript way.


immutable syntax to update object property:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

     return {
                ...prevState, //level -0 copy
                house: {
                    ...prevState.house, // level-1 copy
                    points: prevState.house.points + 2
                }
        }

js syntax:

    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        }
    }

update state:

state.house.points +=2

immer is lib which takes care of writing immutable code on behalf of us, developer writes mutable code, immer converts into immutable code.


Immer core concept:

immer provides a function called "produce"

produce(state,(draft)=>{
   draft.house.points +=2
})

produce function must be written inside this.setState function.


Getting started:

steps:

1.install immer lib

npm i immer

import { produce } from "immer";
import React from "react";

class Review extends React.Component {
    state = {
        house: {
            name: 'RavenClaw',
            points: 10
        },

    }

    onLike = () => {
        //using immutable logic
        // this.setState(prevState => {
        //     return {
        //         ...prevState, //level-0-copy // copy all outer keys of state
        //         house: {
        //             ...prevState.house, // level-1 copy //copy all state except points
        //             points: prevState.house.points + 1
        //         }
        //     }
        // })

        // this.setState(prevState => {
        //     return produce(prevState, draft => {
        //         //write logic
        //         draft.house.points += 1
        //     })
        // })
        // this.setState(prevState => produce(prevState, draft => {
        //     //write logic
        //     draft.house.points += 1
        // }))
        this.setState(produce(this.state, draft => {
            //write logic
            draft.house.points += 1
        }))
    }
    render() {
        return <div>
            <h1>House Review App</h1>
            <h2>{this.state.house.name}</h2>
            <h2>Points {this.state.house.points}</h2>
            <button onClick={this.onLike}>Like</button>
        </div>
    }
}


function App() {
    return <>
        <Review />
    </>
}
export default App;


Another Example:

import React from 'react'
import './index.css'
import { produce } from 'immer'

class Customer extends React.Component {
    state = {
        customer: {
            id: 1,
            name: 'Subramanian',
            contact: {
                address: {
                    city: 'Chennai'
                },
                communcation: {
                    mobileNo: '9000000'
                }
            }
        }
    }
    render() {
        return <div>
            <h1>Customer info</h1>
            <h2>Name : {this.state.customer.name}</h2>
            <h2>Phone : {this.state.customer.contact.communcation.mobileNo}</h2>
            <button onClick={() => {
                this.setState(produce(this.state, (draft) => {
                    draft.customer.contact.communcation.mobileNo = '8883434343'
                }))
            }}>Update Mobile No</button>
        </div>
    }
}

export default function App() {
    return <Customer />
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
						 Component Life cycles
...............................................................................................

React Component life cycle can be classified into three major phases

1.Mount

2.Update

3.UnMount

1.Mount :
  Incase of class component

 1.constructor
     Called only once in the component initalization
     constructors are not used very much...
 2.render
    Called for creating object tree-component tree-Virtual DOM

 3.componentDidMount
    Called after render method, once the dom is ready- once ui is compltly loaded

    This method is used heavily  used in react all versions.

   It is used to inital data fetching from the apis
   It is used to write any async task
   It is used to write websocket connections


2.Update
   When user starts interacting
   when state is mutated  -setState,forceUpdate
   when new props are supplied -state as prop
  
   render
      method is called after state mutation, in order to update ui with new state/
   during render call,it creates vdom, apply an algorthim called "diff", to compute    old tree and new tree, update dom accordingly.
  
   componentDidUpdate
     It is method which is called after render is completed in update cycle.
    incase if you want fetch data from api after dom updates
    incase if you want to do any async tasks.
    
3.UnMount
  When component is removed from memory
 ComponentWillunMount
   any resource clean up task...


import React from "react"

class Parent extends React.Component {
    constructor() {
        super()
        console.log('Parent constructor is called')
    }
    render() {
        console.log('Parent Render is called')
        return <>
            <h1>Parent</h1>
            <Child />
        </>
    }
    componentDidMount() {
        console.log('Parent componentDidMount is called')
    }
    componentDidUpdate() {
        console.log('Parent componentDidUpdate is called')

    }
}

class Child extends React.Component {
    constructor() {
        super()
        console.log('Child constructor is called')
    }
    render() {
        console.log('Child Render is called')
        return <>
            <h1>Child</h1>
        </>
    }
    componentDidMount() {
        console.log('Child componentDidMount is called')
    }
    componentDidUpdate() {
        console.log('Child componentDidUpdate is called')

    }
}

export default function App() {
    return <Parent />
}

..........................................................................................................................................................................................................................................
								API Call and Component Life cycles
..........................................................................................................................................................................................................................................
In order to talk to REST API, react has no any opinion regarding which ajax libs should be used
componentDidMount is used for initialing any async task such as api calls,timers...

Popular ajax libs used inside react

1.fetch
2.axios

import React, { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { produce } from 'immer'

class User extends React.Component {

    state = {
        users: [],  // handle actual user data
        isLoading: false, //handle spinner
        error: null
    }

    async componentDidMount() {
        //const url = 'http://localhost:3000/api/users'
        const url = 'https://jsonplaceholder.typicode.com/users'
        try {
            const response = await fetch(url)
            const users = await response.json()
            this.setState(produce(this.state, (draft) => {
                draft.users = users
                draft.isLoading = true
            }))
        }
        catch (err) {
            console.log(err)
            this.setState(produce(this.state, (draft) => {
                draft.error = err
                draft.isLoading = true
            }))
        }
    }

    render() {
        //conditional render
        const { users, isLoading, error } = this.state
        if (error) {
            return <h1>Something went Wrong {error.message}</h1>
        } else if (!isLoading) {
            return <h1>Loading....</h1>
        } else {
            return <ul>
                {
                    users.map(user => {
                        return <li key={user.id}>
                            <span>{user.name} {user.email}</span>
                        </li>
                    })
                }
            </ul>
        }

    }
}


const App = () => {

    return <>
        <User />
    </>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)
..........................................................................................................................................................................................................................................										Functional components, state,life cycle methods
			 		(Hooks)
....................................................................................


What is hooks and why?

Hooks are simple javascript function which holds Component's logic outside component.

	"Incase of class component , if you define a biz logic, the similar logic if you have in another component, we can't reuse."

React 16 introduced a feature called hooks, by using hooks you can eliminate class components completely, by keeping functional components

Hooks abstract complex  biz logic in reusable manner.

React provides lot of built in hooks to build app , as simple as possible , mean time you can create your own hooks (custom hooks).

Hooks features:

1.hook is simple js function
2.hook can take input and also return values
3.every hook function starts with "useHookName"


Common Built in Hooks

1.useState
   To declare state and mutation inside functions
2.useEffect
   It represents "Life Methods" - compoentDidMount,componentDidUpdate
3.useContext
4.useRef
5.useMemo
6.useCallback
etc......

Thanks to class components ,goodbye to class components....
.....................................................................................
State declaration ,mutation:
...........................

useState:

Syntax:

const [state,setState]=useState(initalState)

state -is just variable it could be any thing, represents current state
setState -  pure function its name generally setVariableName, A function that updates state

const [counter,setCounter]=useState(initalState)

initalState could be

1.primitive values numbers,string,boolean
2.objects
3.arrays

const [counter,setCounter]=useState(0)
const [state,setState]=useState('hello')
const [state,setState]=useState(false)
const [state,setState]=useState(null)
const [state,setState]=useState({count:0})
const [state,setState]=useState([])
..........................................................................................................................................................


Simple state:
import { useState } from "react"

//counter
const Counter = props => {
    //state declaration
    const [counter, setCounter] = useState(0)

    const onIncrement = () => {
        // setCounter(prevState => {
        //     return prevState + 1
        // })
        setCounter(counter + 1)
    }
    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={onIncrement}>+</button>
    </div>
}



export default function App() {
    return <>
        <Counter />
    </>
}
...........................................................................................

Inline Listener:
import { useState } from "react"

const Counter = props => {
    const [counter, setCounter] = useState(0)
    return <div>
        <h1>Counter {counter}</h1>
        <button onClick={() => setCounter(counter + 1)}>+</button>
    </div>
}



export default function App() {
    return <>
        <Counter />
    </>
}
............................
mutli state:

import { useState } from "react"

const Counter = props => {
    const [increment, setIncrement] = useState(0)
    const [decrement, setDecrement] = useState(100)
    return <div>
        <h1>Increment {increment} Decrement {decrement}</h1>
        <button onClick={() => setIncrement(increment + 1)}>+</button>
        <button onClick={() => setDecrement(decrement - 1)}>-</button>

    </div>
}

export default function App() {
    return <>
        <Counter />
    </>
}
............................................................................

Objects and hooks:
import { useState } from "react"

const Counter = props => {
    const [counter, setCounter] = useState({ increment: 0, decrement: 100 })
    return <div>
        <h1>Increment {counter.increment} Decrement {counter.decrement}</h1>
        <button onClick={() => {
            setCounter(prevState => {
                return {
                    ...prevState,
                    increment: prevState.increment + 1
                }
            })
        }}>+</button>
        <button onClick={() => {
            setCounter(prevState => {
                return {
                    ...prevState,
                    decrement: prevState.decrement - 1
                }
            })
        }}>-</button>

    </div>
}

export default function App() {
    return <>
        <Counter />
    </>
}
..........

Objects and hooks: code refactored
import { useState } from "react"

const Counter = props => {
    const [counter, setCounter] = useState({ increment: 0, decrement: 100 })
    return <div>
        <h1>Increment {counter.increment} Decrement {counter.decrement}</h1>
        <button onClick={() => {
            setCounter(({ ...counter, increment: counter.increment + 1 }))
        }}>+</button>
        <button onClick={() => {
            setCounter(({ ...counter, decrement: counter.decrement - 1 }))
        }}>-</button>
    </div>
}

export default function App() {
    return <>
        <Counter />
    </>
}
...............................

Objects,hooks,Immerjs:
.......................
import { produce } from "immer"
import { useState } from "react"

const Counter = props => {
    const [counter, setCounter] = useState({ increment: 0, decrement: 100 })
    return <div>
        <h1>Increment {counter.increment} Decrement {counter.decrement}</h1>
        <button onClick={() => {
            //setCounter(({ ...counter, increment: counter.increment + 1 }))
            setCounter(produce(counter, draft => {
                draft.increment += 1
            }))
        }}>+</button>
        <button onClick={() => {
            // setCounter(({ ...counter, decrement: counter.decrement - 1 }))
            setCounter(produce(counter, draft => {
                draft.decrement -= 1
            }))
        }}>-</button>
    </div>
}

export default function App() {
    return <>
        <Counter />
    </>
}
.................................................................................................................................................................................................
.......................................................................................
		CURD operations using hooks,forms,arrays
........................................................................................
import { produce } from "immer"
import { useState } from "react"

const Post = props => {
    //inital data with some sample posts
    const [posts, setPosts] = useState([
        { id: 1, title: 'Post 1', body: 'this is firstPost' },
        { id: 2, title: 'Post 2', body: 'this is secondPost' }
    ])

    //to handle forms
    const [form, setForm] = useState({ title: '', body: '', id: null })

    //to handle submit button either add or update
    const [isEditing, setIsEditing] = useState(false)

    const updatePost = () => {
        setPosts(posts.map(post => (post.id === form.id ? form : post)));
        setForm({ title: '', body: '', id: null })
        setIsEditing(false)
    }
    const addPost = () => {
        const newPost = { id: Date.now(), title: form.title, body: form.body }
        setPosts([...posts, newPost])
        //reset form
        setForm({ title: '', body: '', id: null })
    }

    //listeners
    const handleSubmit = e => {
        e.preventDefault()
        isEditing ? updatePost() : addPost()
    }

    const handleEdit = post => {
        setForm({ title: post.title, body: post.body, id: post.id })
        setIsEditing(true)
    }

    const deletePost = (id) => {
        setPosts(posts.filter(post => post.id !== id))
    }

    return <div>
        <h1>React CURD Application using Plain Array</h1>
        {/* Form to add new Post */}
        <form onSubmit={handleSubmit}>
            <div>
                <input
                    type="text"
                    placeholder="Title"
                    value={form.title}
                    required
                    onChange={e => setForm({ ...form, title: e.target.value })}
                />
            </div>
            <div>
                <textarea
                    placeholder="Body"
                    value={form.body}
                    required
                    onChange={e => setForm({ ...form, body: e.target.value })}
                />
            </div>
            <div>
                <button type="submit">{isEditing ? 'Update' : 'Add'} Post</button>
            </div>
        </form>

        {/* List of posts */}
        <ul>
            {
                posts.map(post => {
                    return <li key={post.id}>
                        <h2>{post.title}</h2>
                        <p>{post.body}</p>
                        <button onClick={() => {
                            handleEdit(post)
                        }} >Edit</button>
                        <button onClick={() => {
                            deletePost(post.id)
                        }} >Delete</button>
                    </li>
                })
            }
        </ul>
    </div>
}

export default function App() {
    return <>
        <Post />
    </>
}
..............................................................................................
			component Life Cycles and Hooks
.....................................................................................

render,componentDidMount,componentDidUpdate,componentWillUnMount

useEffect:
comonentDidMount,componentDidupdate,componentWillUnMount
    =>useEffect

componentDidMount:
useEffect(()=>{},[]) - useEffect(function,<dependency>)
useEffect(()=>{})    - useEffect(function)

ComponentDidUpdate
useEffect(()=>{},[state])
 here if state is updated, then this hook will be called


import { StrictMode, useEffect, useState } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { produce } from "immer"

const Products = () => {
    const initialState = {
        products: [],
        isLoading: false, //to show spinner
        error: null
    }
    const [products, setProducts] = useState(initialState)

    const fetchProducts = async () => {
        try {
            const url = `https://api.escuelajs.co/api/v1/products`
            const response = await fetch(url)
            const tmpProducts = await response.json()
            setProducts(produce(products, (draft) => {
                draft.products = tmpProducts,
                draft.isLoading = true
            }))
            console.log(products)
        }
        catch (err) {
            setProducts(produce(products, (draft) => {
                draft.err = err
                draft.isLoading = true
            }))
        }
    }

    useEffect(() => {
        //api call 
        fetchProducts()
    }, [])

     //conditional rendering: how to use if...else..elseif
     if (products.error) {
        return <div>
            <h1>Error : {error.message}</h1>
        </div>
    } else if (!products.isLoading) {
        return <h2>Loading...</h2>
    } else {
        return <div>
            <h1>Products</h1>
            <hr />
            <div>
                {
                    products.products.map(product => {
                        return <section>
                            <img src={product.category.image} height={200} width={200} />
                            <h1>{product.title} </h1>
                            <p>{product.description}</p>
                            <h5>{product.price}</h5>
                        </section>
                    })
                }
            </div>
        </div>
    }
}


const App = () => {
    return <Products />
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)
.....................................................................................
				Redux -State Management lib
.....................................................................................

What is state?
 State is nothing data.

State is managed within component.

What if i want to share the state across the application, there is pattern called "Lift up the state", pass as prop.

In state management , redux is going to act as state layer, react is going act as UI layer.

React and Redux is based on the design pattern "Flux Pattern"


https://facebookarchive.github.io/flux/


Action---->dispatcher----->Store<--->[Reducer] 
			    |
			    |
			 View-React


What is Redux -  Red-reducer + ux (Flux) => Reducer + Flux

What is Reducer?
  Reducer is pure function, which accepts input, returns immutable object...
  Reducer is having biz logic.
  Who calls reducer, reducer is called by store..
  UI Layer never communicates biz logic (reducer) directly.
  UI Layer sends request(action) --via dispatcher---to the store, then store reacts   to that

Core Concepts or Principles:
....................................................

1.State:
   Redux maintains or stores the data in "single object" Redux is going to store all 
component state into one single object -Application State

const appState = {
  ....   
} called as application state.

How appState is identified for each component?

Based on category/module.

const appState = {
  
  order: {
    
  },
  customer: {},
  product:{}

} 
2.Store
   Store is object where Redux application state lives.
   Store offers api to communicate from react and redux to react
   Store is entry and exit point of react and redux
   Per application , there is single store, that store is having state..

3.reducer
    You know very well how to mutate and where mutate state in react
     ->Inside setState pure function.
    Reducer is pure function which returns immutable object.

4.actions
    An action is like request in webserver, redux actions are plain javascript object
 eg:
  let counterAction = {
	type:'counter/increment'
  }
 action may take input also called payload
  let counterByAmount = {
   type:'counter/increment',
   payload:2
 }
5.Dispatcher 
  It is transporter which transport action object from react to redux
  Dispatcher is represented by a method called "dispatch"
  dispatch is part of "Store object"
  store.dispatch(action)

Why redux?
  Redux is used in big applications where the app state is shared across multiple components
  Redux is used in big application where team of developers works in a different modules.
.....................................................................................

Project Setup:
npm create vite@latest myreact-redux

dependencies

npm install @reduxjs/toolkit react-redux

Without Redux:
import { useState } from "react"

const Counter = () => {
  const [count, setCount] = useState(0)

  const onIncrement = () => {
    setCount(count + 1)
  }
  return <div>
    <h1>Count {count}</h1>
    <button onClick={onIncrement}>+</button>
  </div>
}



export default function App() {

  return <>
    <h1>React Redux Integration</h1>
    <Counter/>
  </>
}

Use case: simple counter reducer:

in order to write reducer we have many syntax...

old way -plain redux

new way -redux toolkit


Old-way:

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'

//redux : reducer (initalState,actionObject)
const CounterReducer = (counter = 10, action) => {
  //methods
  switch (action.type) {
    case 'counter/increment':
      return counter + 1
    default:
      //default state
      return counter;
  }
}

//create store object
const appStore = configureStore({
  reducer: {
    counter: CounterReducer
  }
})
///////////////////////////////////////////////////////////////////////////////////////
//React component layer
const Counter = (props) => {
  const counter = useSelector(state => {
    //appState.reducerName
    return state.counter
  })

  const dispatch = useDispatch()

  const onIncrement = () => {
    //action object
    const incrementAction = {
      type: 'counter/increment'
    }
    //dispatch an action to reducer
    dispatch(incrementAction)
  }
  return <div>
    <h1>React Redux</h1>
    <h2>Counter {counter}</h2>
    <button onClick={onIncrement}>+</button>
  </div>
}



///
//connecting react with redux: That should be top level component.

//react-redux lib provides a context object through which we can pass store object into
//react components
const App = () => {
  return <Provider store={appStore}>
    {/* Your components */}
    <Counter />
  </Provider>
}

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
....................................................................................
			 Multi Biz logic
...................................................................................
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'

//redux : reducer (initalState,actionObject)
const CounterReducer = (counter = 10, action) => {
    //methods
    switch (action.type) {
        case 'counter/increment':
            return counter + 1
        case 'counter/decrement':
            return counter - 1
        default:
            //default state
            return counter;
    }
}

//create store object
const appStore = configureStore({
    reducer: {
        counter: CounterReducer
    }
})
///////////////////////////////////////////////////////////////////////////////////////
//React component layer
const Counter = (props) => {
    const counter = useSelector(state => {
        //appState.reducerName
        return state.counter
    })

    const dispatch = useDispatch()

    const onIncrement = () => {
        //action object
        const incrementAction = {
            type: 'counter/increment'
        }
        //dispatch an action to reducer
        dispatch(incrementAction)
    }
    return <div>
        <h1>React Redux</h1>
        <h2>Counter {counter}</h2>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: 'counter/decrement' })
        }}>-</button>

    </div>
}



///
//connecting react with redux: That should be top level component.

//react-redux lib provides a context object through which we can pass store object into
//react components
const App = () => {
    return <Provider store={appStore}>
        {/* Your components */}
        <Counter />
    </Provider>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)
..................................................................................
			 How to pass input to reducer-payload
.....................................................................................


import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import { configureStore } from '@reduxjs/toolkit'
import { Provider, useDispatch, useSelector } from 'react-redux'

//redux : reducer (initalState,actionObject)
const CounterReducer = (counter = 10, action) => {
    //methods
    switch (action.type) {
        case 'counter/increment':
            return counter + 1
        case 'counter/decrement':
            return counter - 1
        case 'counter/incrementBy':
            return counter + action.payload

        default:
            //default state
            return counter;
    }
}

//create store object
const appStore = configureStore({
    reducer: {
        counter: CounterReducer
    }
})
///////////////////////////////////////////////////////////////////////////////////////
//React component layer
const Counter = (props) => {
    const counter = useSelector(state => {
        //appState.reducerName
        return state.counter
    })

    const dispatch = useDispatch()

    const onIncrement = () => {
        //action object
        const incrementAction = {
            type: 'counter/increment'
        }
        //dispatch an action to reducer
        dispatch(incrementAction)
    }
    return <div>
        <h1>React Redux</h1>
        <h2>Counter {counter}</h2>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: 'counter/decrement' })
        }}>-</button>
        <button onClick={() => {
            dispatch({ type: 'counter/incrementBy', payload: 2 })
        }}>IncrementBy</button>

    </div>
}



///
//connecting react with redux: That should be top level component.

//react-redux lib provides a context object through which we can pass store object into
//react components
const App = () => {
    return <Provider store={appStore}>
        {/* Your components */}
        <Counter />
    </Provider>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)
..........................................................................................

Objects and mutations:
import { configureStore } from "@reduxjs/toolkit";
import { useDispatch, useSelector } from "react-redux";

//reducer-old way
const CounterReducer = (count = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case 'counter/increment':
            //immutable logic//pure function
            return { ...count, value: count.value + 1 }
        case 'counter/incrementBy':
            //immutable logic//pure function
            return { ...count, value: count.value + action.payload }

        case 'counter/decrement':
            //immutable logic//pure function
            return { ...count, value: count.value - 1 }
        default:
            return count; //default state
    }
}

//step 2 store object
export const store = configureStore({
    reducer: {
        //nameofReducer: ReducerFunction
        counter: CounterReducer
    }
})


const Counter = () => {
    const count = useSelector(state => {
        return state.counter
    })
    const dispatch = useDispatch()

    const onIncrement = () => {
        dispatch({ type: 'counter/increment' })
    }
    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: 'counter/decrement' })
        }}>-</button>

        <button onClick={() => {
            dispatch({ type: 'counter/incrementBy', payload: 2 })
        }}>IncrementByTwo</button>

    </div>
}


export default function App() {

    return <>
        <h1>React Redux Integration</h1>
        <Counter />
    </>
}
............................................................................................
			 Action constant
...........................................................................................
import { configureStore } from "@reduxjs/toolkit";
import { useDispatch, useSelector } from "react-redux";

//action constant
const counterIncrementAction = 'counter/increment'
const counterIncrementByAction = 'counter/incrementBy'
const counterDecrementAction = 'counter/decrement'

//reducer-old way
const IncrementReducer = (count = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case counterIncrementAction:
            //immutable logic//pure function
            return { ...count, value: count.value + 1 }
        case counterIncrementByAction:
            //immutable logic//pure function
            return { ...count, value: count.value + action.payload }
        default:
            return count; //default state
    }
}
const DecrementReducer = (count = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case counterDecrementAction:
            //immutable logic//pure function
            return { ...count, value: count.value - 1 }
        default:
            return count; //default state
    }
}
//step 2 store object
export const store = configureStore({
    reducer: {
        //nameofReducer: ReducerFunction
        increment: IncrementReducer,
        decrement: DecrementReducer
    }
})

const Increment = () => {
    const count = useSelector(state => {
        return state.increment
    })
    const dispatch = useDispatch()
    const onIncrement = () => {
        dispatch({ type: counterIncrementAction })
    }
    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: counterIncrementByAction, payload: 2 })
        }}>IncrementByTwo</button>

    </div>
}

const Decrement = () => {
    const count = useSelector(state => {
        return state.decrement
    })
    const dispatch = useDispatch()

    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={() => {
            dispatch({ type: counterDecrementAction })
        }}>-</button>
    </div>
}

const Counter = () => {

    return <>
        <Increment />
        <Decrement />
    </>
}

export default function App() {

    return <>
        <h1>React Redux Integration</h1>
        <Counter />
    </>
}
.............................................................................................
				Action Creators
.............................................................................................

action creator is function which returns action object.
action creators are used when you pass dynamic input to the reducer.



import { configureStore } from "@reduxjs/toolkit";
import { useDispatch, useSelector } from "react-redux";

//action constant
const counterIncrementAction = 'counter/increment'
const counterIncrementByAction = 'counter/incrementBy'
const counterDecrementAction = 'counter/decrement'

//reducer-old way
const IncrementReducer = (count = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case counterIncrementAction:
            //immutable logic//pure function
            return { ...count, value: count.value + 1 }
        case counterIncrementByAction:
            //immutable logic//pure function
            return { ...count, value: count.value + action.payload }
        default:
            return count; //default state
    }
}
const DecrementReducer = (count = { value: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case counterDecrementAction:
            //immutable logic//pure function
            return { ...count, value: count.value - 1 }
        default:
            return count; //default state
    }
}
//step 2 store object
export const store = configureStore({
    reducer: {
        //nameofReducer: ReducerFunction
        increment: IncrementReducer,
        decrement: DecrementReducer
    }
})

const Increment = () => {
    const count = useSelector(state => {
        return state.increment
    })
    const dispatch = useDispatch()


    const onIncrement = () => {
        dispatch({ type: counterIncrementAction })
    }

    //action creator
    // function incrementBy(payload) {
    //     return {
    //         type: counterIncrementByAction,
    //         payload: payload
    //     }
    // }
    //action creator
    const incrementBy = payload => ({
        type: counterIncrementByAction,
        payload
    })

    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch(incrementBy(2))
        }}>IncrementByTwo</button>

    </div>
}

const Decrement = () => {
    const count = useSelector(state => {
        return state.decrement
    })
    const dispatch = useDispatch()

    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={() => {
            dispatch({ type: counterDecrementAction })
        }}>-</button>
    </div>
}

const Counter = () => {

    return <>
        <Increment />
        <Decrement />
    </>
}



export default function App() {

    return <>
        <h1>React Redux Integration</h1>
        <Counter />
    </>
}

Multi reducer:
import { configureStore } from '@reduxjs/toolkit'
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { Provider, useDispatch, useSelector } from 'react-redux'

//action constant
const counterIncrement = 'counter/increment'
const counterDecrement = 'counter/decrement'
const counterIncrementBy = 'counter/incrementBy'

const IncrementReducer = (count = { value: 10 }, action) => {
    switch (action.type) {
        case counterIncrement:
            return { ...count, value: count.value + 1 }
        default:
            return count
    }
}
const IncrementByReducer = (count = { value: 10 }, action) => {
    switch (action.type) {
        case counterIncrementBy:
            return { ...count, value: count.value + action.payload }
        default:
            return count
    }
}
const DecrementReducer = (count = { value: 10 }, action) => {
    switch (action.type) {
        case counterDecrement:
            return { ...count, value: count.value - 1 }
        default:
            return count
    }
}
const store = configureStore({
    reducer: {
        increment: IncrementReducer,
        incrementBy: IncrementByReducer,
        decrement: DecrementReducer
    }
})

//react 

function Increment() {
    const counter = useSelector(state => {
        return state.increment
    })
    console.log('counter',counter)

    return <h1>Increment : {counter.value}</h1>
}
function Decrement() {
    const counter = useSelector(state => {
        return state.decrement
    })
    return <h1>Decrement : {counter.value}</h1>
}
function IncrementBy() {
    const counter = useSelector(state => {
        return state.incrementBy
    })
    return <h1>IncrementBy : {counter.value}</h1>
}
function Counter() {
    return <div>
        <Increment />
        <Decrement/>
        <IncrementBy/>
    </div>
}


function App() {
    return <Provider store={store}>
        <Counter />
    </Provider>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)

Using immer js produce function
import { configureStore } from '@reduxjs/toolkit'
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { Provider, useDispatch, useSelector } from 'react-redux'
import { produce } from 'immer'

//action constant
const counterIncrement = 'counter/increment'
const counterDecrement = 'counter/decrement'
const counterIncrementBy = 'counter/incrementBy'

const CounterReducer = (count = { value: 10 }, action) => {
    switch (action.type) {
        case counterIncrement:
            // return { ...count, value: count.value + 1 }
            return produce(count, (draft) => {
                draft.value += 1
            })
        case counterIncrementBy:
            //return { ...count, value: count.value + action.payload }
            return produce(count, (draft) => {
                draft.value += action.payload
            })
        case counterDecrement:
            // return { ...count, value: count.value - 1 }
            return produce(count, (draft) => {
                draft.value -= 1
            })
        default:
            return count
    }
}
const store = configureStore({
    reducer: {
        counter: CounterReducer
    }
})

//react 

function Counter() {
    const count = useSelector(state => {
        return state.counter
    })
    const dispatch = useDispatch()

    const onIncrement = () => {
        //send action to store via dispatcher
        const incrementAction = {
            type: counterIncrement
        }
        dispatch(incrementAction)
    }
    return <div>
        <h2>Counter : {count.value}</h2>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: counterDecrement })
        }}>-</button>
        <button onClick={() => {
            dispatch({ type: counterIncrementBy, payload: 2 })
        }}>IncrementBy</button>

    </div>
}


function App() {
    return <Provider store={store}>
        <Counter />
    </Provider>
}

createRoot(document.getElementById('root')).render(
    <StrictMode>
        <App />
    </StrictMode>,
)


..............................................................................................
.....................................................................................
			 Modern Reducer syntax
....................................................................................


Old way:

const IncrementReducer = (state = { counter: 10 }, action) => {
    //biz logic
    switch (action.type) {
        case incrementBy:
            return produce(state, (draft) => {
                draft.counter += action.payload
            })
        default:
            //default state
            return state;
    }

}

Redux Toolkit way:

1.using createReducer function
2.using createSlice function

2.1.Using createReducer api

1.It is utility function from redux-toolkit.
2.It reduces lot of boiler plate code , provides standards based coding
3.It is offering built in immer js api, so, no need of using "produce" directly..
4.No need of switch..case and actions...


createReducer api coding has  pattern

1.builder pattern

Syntax:

const reducer= createReducer(initialState,(builder)=>{

     builder.addCase(actionName,(state,action)=>{
     //immer js code: produce function is built in
      state.value++
    }).addCase(actionName,(state,action)=>{
     //immer js code: produce function is built in
      state.value++
   }).addDefaultCase((state,action)=>{})

})

import { configureStore, createReducer } from "@reduxjs/toolkit";
import { useDispatch, useSelector } from "react-redux";

//reducer-old way
// const CounterReducer = (count = 10, action) => {
//     //biz logic
//     switch (action.type) {
//         case 'counter/increment':
//             //immutable logic//pure function
//             return count + 1

//         case 'counter/decrement':
//             //immutable logic//pure function
//             return count - 1
//         default:
//             return count; //default state
//     }
// }
//using createReducer function

let initialState = { value: 0 }
const incrementAction = 'counter/increment'
const decrementAction = 'counter/decrement'

const CounterReducer = createReducer(initialState, builder => {
    //biz logic
    builder.addCase(incrementAction, (state, action) => {
        //immer js code directly
        state.value += 1
    }).addCase(decrementAction, (state, action) => {
        //immer js code directly
        state.value -= 1
    }).addDefaultCase((state, action) => { })
})

//step 2 store object
export const store = configureStore({
    reducer: {
        //nameofReducer: ReducerFunction
        counter: CounterReducer
    }
})


const Counter = () => {
    const count = useSelector(state => {
        return state.counter
    })
    const dispatch = useDispatch()

    const onIncrement = () => {
        dispatch({ type: incrementAction })
    }
    return <div>
        <h1>Count {count.value}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={() => {
            dispatch({ type: decrementAction })
        }}>-</button>

    </div>
}



export default function App() {

    return <>
        <h1>React Redux Integration</h1>
        <Counter />
    </>
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
											Middlewares
.........................................................................................................................................................................................................................................
What is middleware?
 	Middleware is collection of functions, used for some cross cutting concerns...

eg:
logging
TimeTravel
async task

This function has already default Middlewars

1.Immutability check middleware
2.Serializability check middleware
3.Action creator check middleware
4.thunk -  For api calls / For async task
 +
Your middlewares

To add Middleware

Way 1:

const middlewares = [thunk,immutableStateInvariant,seralizableStateInvariant]

configureStore({
 middleware: middlewares
})

way 2:
configureStore({
 middleware: (getDefaultMiddleware)=>getDefaultMiddleware().concat(yourMiddleware)
})

eg:
logger:
npm i --save redux-logger

import { createSlice } from '@reduxjs/toolkit';
import { configureStore } from '@reduxjs/toolkit';
import React, { useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import logger from 'redux-logger';

const initialState = {
    items: [
        { id: 1, name: 'Item 1' },
        { id: 2, name: 'Item 2' },
    ],
};

const itemsSlice = createSlice({
    name: 'items',
    initialState,
    reducers: {
        addItem: (state, action) => {
            const newItem = {
                id: state.items.length > 0 ? state.items[state.items.length - 1].id + 1 : 1,
                name: action.payload,
            };
            //immutable api
            state.items.push(newItem);
        },
        updateItem: (state, action) => {
            const { id, name } = action.payload;
            const item = state.items.find((item) => item.id === id);
            if (item) {
                item.name = name;
            }
        },
        deleteItem: (state, action) => {
            state.items = state.items.filter((item) => item.id !== action.payload);
        },
    },
});
export const { addItem, updateItem, deleteItem } = itemsSlice.actions;
export const itemsReducer = itemsSlice.reducer;

export const store = configureStore({
    reducer: {
        items: itemsReducer,

    },
    //get all default middlewares and add your own middleware
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger)
});

const App = () => {
    const items = useSelector((state) => state.items.items);
    const dispatch = useDispatch();

    const [newItem, setNewItem] = useState('');
    const [editingItem, setEditingItem] = useState(null);
    const [editingName, setEditingName] = useState('');

    const handleAdd = () => {
        if (newItem.trim()) {
            dispatch(addItem(newItem));
            setNewItem('');
        }
    };

    const handleUpdate = (id) => {
        if (editingName.trim()) {
            dispatch(updateItem({ id, name: editingName }));
            setEditingItem(null);
            setEditingName('');
        }
    };

    return (
        <div style={{ padding: '20px' }}>
            <h1>CRUD with Redux Toolkit</h1>
            <div>
                <input
                    type="text"
                    placeholder="Add new item"
                    value={newItem}
                    onChange={(e) => setNewItem(e.target.value)}
                />
                <button onClick={handleAdd}>Add</button>
            </div>
            <ul>
                {items.map((item) => (
                    <li key={item.id}>
                        {editingItem === item.id ? (
                            <>
                                <input
                                    type="text"
                                    value={editingName}
                                    onChange={(e) => setEditingName(e.target.value)}
                                />
                                <button onClick={() => handleUpdate(item.id)}>Save</button>
                                <button onClick={() => setEditingItem(null)}>Cancel</button>
                            </>
                        ) : (
                            <>
                                {item.name}{' '}
                                <button onClick={() => {
                                    setEditingItem(item.id);
                                    setEditingName(item.name);
                                }}>
                                    Edit
                                </button>{' '}
                                <button onClick={() => dispatch(deleteItem(item.id))}>Delete</button>
                            </>
                        )}
                    </li>
                ))}
            </ul>
        </div>
    );
};

export default App;

....................................................................................
			 REST API CALLS INSIDE Redux
....................................................................................
After integrating redux with react, all api logic should be part of redux

There are two code:

1.middleware code for making api call -  createAsyncThunk
2.slice code for getting data from the api and send to ui.



import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import { configureStore } from '@reduxjs/toolkit';
import React, { useState, useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import logger from 'redux-logger';

//middleware for making api calls

//Fetch users from the api
//promise state variables are added automatically, to track promises
//'users/fetchUsers/pending' or users/fetchUsers/completed ,users/fetchUsers/failed
export const fetchUsers = createAsyncThunk('users/fetchUsers', async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users')
    return response.json()
})

// Add a new user
export const addUser = createAsyncThunk('users/addUser', async (newUser) => {
    const response = await fetch('https://jsonplaceholder.typicode.com/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser),
    });
    return response.json();
});
// Update an existing user
export const updateUser = createAsyncThunk('users/updateUser', async ({ id, updatedUser }) => {
    const response = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedUser),
    });
    return response.json();
});
// Delete a user
export const deleteUser = createAsyncThunk('users/deleteUser', async (id) => {
    await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
        method: 'DELETE',
    });
    return id;
});
//slice

const usersSlice = createSlice({
    name: 'users',
    initialState: {
        list: [],
        status: 'idle', // idle | loading | succeeded | failed
        error: null,
    },
    reducers: {},
    extraReducers: (builder) => {
        builder
            // Fetch Users
            .addCase(fetchUsers.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchUsers.fulfilled, (state, action) => {
                state.status = 'succeeded';
                state.list = action.payload;
            })
            .addCase(fetchUsers.rejected, (state, action) => {
                state.status = 'failed';
                state.error = action.error.message;
            })

            // Add User
            .addCase(addUser.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(addUser.fulfilled, (state, action) => {
                state.status = 'succeeded';
                state.list.push(action.payload);
            })
            .addCase(addUser.rejected, (state, action) => {
                state.status = 'failed';
                state.error = action.error.message;
            })

            // Update User
            .addCase(updateUser.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(updateUser.fulfilled, (state, action) => {
                state.status = 'succeeded';
                const index = state.list.findIndex((user) => user.id === action.payload.id);
                state.list[index] = action.payload;
            })
            .addCase(updateUser.rejected, (state, action) => {
                state.status = 'failed';
                state.error = action.error.message;
            })

            // Delete User
            .addCase(deleteUser.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(deleteUser.fulfilled, (state, action) => {
                state.status = 'succeeded';
                state.list = state.list.filter((user) => user.id !== action.payload);
            })
            .addCase(deleteUser.rejected, (state, action) => {
                state.status = 'failed';
                state.error = action.error.message;
            });
    },
});

const UserReducer = usersSlice.reducer

export const store = configureStore({
    reducer: {
        users: UserReducer,
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger)
});

function UserItem({ user, onEdit, onDelete }) {
    return (
        <li>
            <span>{user.name} ({user.email})</span>
            <button onClick={() => onEdit(user)}>Edit</button>
            <button onClick={() => onDelete(user.id)}>Delete</button>
        </li>
    );
}

function Users() {
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [editingUser, setEditingUser] = useState(null);

    const { list: users, status, error } = useSelector((state) => state.users);
    const dispatch = useDispatch();

    useEffect(() => {
        dispatch(fetchUsers());
    }, [dispatch]);

    const handleAddOrUpdateUser = () => {
        if (editingUser) {
            dispatch(updateUser({ id: editingUser.id, updatedUser: { name, email } }));
            setEditingUser(null);
        } else {
            dispatch(addUser({ name, email }));
        }
        setName('');
        setEmail('');
    };

    const handleEdit = (user) => {
        setEditingUser(user);
        setName(user.name);
        setEmail(user.email);
    };

    const handleDelete = (id) => {
        dispatch(deleteUser(id));
    };

    return (
        <div>
            <h1>User Management</h1>

            {/* Loading or Error Messages */}
            {status === 'loading' && <p>Loading...</p>}
            {status === 'failed' && <p style={{ color: 'red' }}>Error: {error}</p>}

            {/* User Input */}
            <div>
                <input
                    type="text"
                    placeholder="Name"
                    value={name}
                    onChange={(e) => setName(e.target.value)}
                />
                <input
                    type="email"
                    placeholder="Email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                />
                <button onClick={handleAddOrUpdateUser}>
                    {editingUser ? 'Update User' : 'Add User'}
                </button>
            </div>

            {/* User List */}
            {status === 'succeeded' && (
                <ul>
                    {users.map((user) => (
                        <UserItem
                            key={user.id}
                            user={user}
                            onEdit={handleEdit}
                            onDelete={handleDelete}
                        />
                    ))}
                </ul>
            )}
        </div>
    );
}

export default function App() {
    return <Users />
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&





